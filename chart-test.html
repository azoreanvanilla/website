<!DOCTYPE html>
<html>
<head>
  <title>Chart Rendering - Complete Rewrite Test</title>
  <style>
    body { font-family: monospace; padding: 20px; background: #1a1a1a; color: #fff; }
    .test { background: #222; padding: 20px; margin: 20px 0; border: 1px solid #444; border-radius: 5px; }
    h2 { color: #0066cc; }
    svg { border: 2px solid #444; background: #f5f5f5; display: block; margin: 20px 0; }
    .info { font-size: 0.85em; color: #aaa; margin: 10px 0; }
    .success { color: #00ff00; }
    .error { color: #ff4444; }
  </style>
</head>
<body>
  <h1>Chart Rendering - Complete Rewrite</h1>
  
  <div class="test">
    <h2>Test 1: Synthetic 24-Hour Data</h2>
    <div class="info" id="test1-info">Generating data...</div>
    <svg viewBox="0 0 900 250" style="width: 100%; max-width: 900px; height: 300px;">
      <defs>
        <linearGradient id="grad1" x1="0%" y1="0%" x2="0%" y2="100%">
          <stop offset="0%" style="stop-color:#cce5ff;stop-opacity:0.3" />
          <stop offset="100%" style="stop-color:#ffffff;stop-opacity:0" />
        </linearGradient>
        <clipPath id="clip1">
          <rect x="50" y="20" width="820" height="180"/>
        </clipPath>
      </defs>
      <!-- Y-AXIS -->
      <text x="30" y="30" font-size="11" fill="#666" text-anchor="end">32</text>
      <text x="30" y="110" font-size="11" fill="#666" text-anchor="end">24</text>
      <text x="30" y="190" font-size="11" fill="#666" text-anchor="end">16</text>
      <!-- AXES -->
      <line x1="50" y1="20" x2="50" y2="200" stroke="#999" stroke-width="1"/>
      <line x1="50" y1="200" x2="870" y2="200" stroke="#999" stroke-width="1"/>
      <!-- X LABELS -->
      <text x="50" y="220" font-size="10" fill="#666" text-anchor="middle">00:00</text>
      <text x="170" y="220" font-size="10" fill="#666" text-anchor="middle">04:00</text>
      <text x="290" y="220" font-size="10" fill="#666" text-anchor="middle">08:00</text>
      <text x="410" y="220" font-size="10" fill="#666" text-anchor="middle">12:00</text>
      <text x="530" y="220" font-size="10" fill="#666" text-anchor="middle">16:00</text>
      <text x="650" y="220" font-size="10" fill="#666" text-anchor="middle">20:00</text>
      <text x="770" y="220" font-size="10" fill="#666" text-anchor="middle">24:00</text>
      <!-- RANGE SHADING -->
      <rect x="50" y="50" width="820" height="100" fill="url(#grad1)" opacity="0.5"/>
      <!-- POLYLINE WILL BE RENDERED HERE -->
      <polyline id="test1-line" points="" fill="none" stroke="#0066cc" stroke-width="2" stroke-linejoin="round" clip-path="url(#clip1)"/>
    </svg>
  </div>

  <div class="test">
    <h2>Test 2: Real Data (from CSV)</h2>
    <div class="info" id="test2-info">Loading...</div>
    <svg viewBox="0 0 900 250" style="width: 100%; max-width: 900px; height: 300px;">
      <defs>
        <linearGradient id="grad2" x1="0%" y1="0%" x2="0%" y2="100%">
          <stop offset="0%" style="stop-color:#cce5ff;stop-opacity:0.3" />
          <stop offset="100%" style="stop-color:#ffffff;stop-opacity:0" />
        </linearGradient>
        <clipPath id="clip2">
          <rect x="50" y="20" width="820" height="180"/>
        </clipPath>
      </defs>
      <!-- Y-AXIS -->
      <text x="30" y="30" font-size="11" fill="#666" text-anchor="end">32</text>
      <text x="30" y="110" font-size="11" fill="#666" text-anchor="end">24</text>
      <text x="30" y="190" font-size="11" fill="#666" text-anchor="end">16</text>
      <!-- AXES -->
      <line x1="50" y1="20" x2="50" y2="200" stroke="#999" stroke-width="1"/>
      <line x1="50" y1="200" x2="870" y2="200" stroke="#999" stroke-width="1"/>
      <!-- X LABELS -->
      <text x="50" y="220" font-size="10" fill="#666" text-anchor="middle">00:00</text>
      <text x="170" y="220" font-size="10" fill="#666" text-anchor="middle">04:00</text>
      <text x="290" y="220" font-size="10" fill="#666" text-anchor="middle">08:00</text>
      <text x="410" y="220" font-size="10" fill="#666" text-anchor="middle">12:00</text>
      <text x="530" y="220" font-size="10" fill="#666" text-anchor="middle">16:00</text>
      <text x="650" y="220" font-size="10" fill="#666" text-anchor="middle">20:00</text>
      <text x="770" y="220" font-size="10" fill="#666" text-anchor="middle">24:00</text>
      <!-- RANGE SHADING -->
      <rect x="50" y="50" width="820" height="100" fill="url(#grad2)" opacity="0.5"/>
      <!-- POLYLINE WILL BE RENDERED HERE -->
      <polyline id="test2-line" points="" fill="none" stroke="#0066cc" stroke-width="2" stroke-linejoin="round" clip-path="url(#clip2)"/>
    </svg>
  </div>

  <script>
    // ===== CHART RENDERING ENGINE =====
    class ChartRenderer {
      constructor(svgSelector, dataKey = 'temp', minVal = 14, maxVal = 32) {
        this.svg = document.querySelector(svgSelector);
        this.polyline = this.svg.querySelector('polyline');
        this.dataKey = dataKey;
        this.minVal = minVal;
        this.maxVal = maxVal;
        
        // Chart dimensions (FIXED)
        this.xMin = 50;
        this.xMax = 870;
        this.yTop = 20;
        this.yBottom = 200;
        this.xRange = this.xMax - this.xMin;
        this.yRange = this.yBottom - this.yTop;
      }

      parseDate(timeStr) {
        if (!timeStr) return null;
        const parts = timeStr.match(/(\d{4})-(\d{2})-(\d{2})\s+(\d{2}):(\d{2}):(\d{2})/);
        if (!parts) return null;
        return new Date(parts[1], parts[2] - 1, parts[3], parts[4], parts[5], parts[6]);
      }

      render(data) {
        if (!data || data.length < 1) {
          console.error('No data to render');
          return false;
        }

        try {
          // Get time boundaries
          const firstDate = this.parseDate(data[0].timestamp);
          const lastDate = this.parseDate(data[data.length - 1].timestamp);
          
          if (!firstDate || !lastDate) {
            console.error('Failed to parse dates');
            return false;
          }

          const timeSpanMs = lastDate.getTime() - firstDate.getTime();
          if (timeSpanMs <= 0) {
            console.error('Invalid time span');
            return false;
          }

          // Find actual data min/max for scaling
          let dataMin = Infinity, dataMax = -Infinity;
          data.forEach(d => {
            const val = d[this.dataKey];
            if (val !== undefined) {
              dataMin = Math.min(dataMin, val);
              dataMax = Math.max(dataMax, val);
            }
          });

          // Use provided min/max or data extremes
          const minVal = this.minVal !== null ? this.minVal : dataMin;
          const maxVal = this.maxVal !== null ? this.maxVal : dataMax;
          const valRange = maxVal - minVal;

          if (valRange <= 0) {
            console.error('Invalid value range');
            return false;
          }

          // Generate polyline points
          let points = [];
          data.forEach((point, idx) => {
            const pointDate = this.parseDate(point.timestamp);
            if (!pointDate) return;

            // Calculate X position
            const msFromStart = pointDate.getTime() - firstDate.getTime();
            const timeProgress = msFromStart / timeSpanMs;
            const x = this.xMin + (timeProgress * this.xRange);

            // Calculate Y position
            const val = point[this.dataKey];
            const normalized = (val - minVal) / valRange;
            const y = this.yBottom - (normalized * this.yRange);

            // Clamp to bounds
            const xClamped = Math.max(this.xMin, Math.min(this.xMax, x));
            const yClamped = Math.max(this.yTop, Math.min(this.yBottom, y));

            points.push(`${xClamped.toFixed(1)},${yClamped.toFixed(1)}`);

            if (idx === 0 || idx === data.length - 1) {
              console.log(`Point ${idx}: val=${val.toFixed(2)}, x=${x.toFixed(1)}→${xClamped.toFixed(1)}, y=${y.toFixed(1)}→${yClamped.toFixed(1)}`);
            }
          });

          this.polyline.setAttribute('points', points.join(' '));

          return {
            pointCount: data.length,
            timeSpan: (timeSpanMs / 1000 / 60 / 60).toFixed(2),
            dataRange: `${dataMin.toFixed(2)}-${dataMax.toFixed(2)}`,
            scaled: `${minVal}-${maxVal}`
          };
        } catch (e) {
          console.error('Render error:', e);
          return false;
        }
      }
    }

    // ===== SYNTHETIC DATA GENERATOR =====
    function generateSynthetic24h(startDate) {
      const data = [];
      let currentTime = new Date(startDate);
      
      for (let i = 0; i < 288; i++) { // 24h × 5min intervals = 288 points
        const hour = currentTime.getHours() + currentTime.getMinutes() / 60;
        
        // Realistic temperature curve
        const tempCurve = Math.sin((hour - 6) / 24 * Math.PI * 2);
        const temp = 20 + tempCurve * 6 + (Math.random() - 0.5) * 0.8;
        
        const timestamp = currentTime.toISOString()
          .substring(0, 19)
          .replace('T', ' ');
        
        data.push({
          timestamp,
          temp: Math.max(14, Math.min(32, temp)),
          humidity: 75,
          vpd: 1.0
        });
        
        currentTime = new Date(currentTime.getTime() + 5 * 60 * 1000);
      }
      
      return data;
    }

    // ===== RUN TESTS =====
    window.addEventListener('load', () => {
      console.log('=== Chart Rendering Tests ===\n');

      // TEST 1: Synthetic data
      console.log('--- TEST 1: Synthetic 24h Data ---');
      const synth = generateSynthetic24h(new Date('2026-01-10T00:00:00'));
      const renderer1 = new ChartRenderer('#test1-line', 'temp', 14, 32);
      const result1 = renderer1.render(synth);
      
      if (result1) {
        document.getElementById('test1-info').innerHTML = 
          `<span class="success">✓ PASSED</span> | ${result1.pointCount} points | ${result1.timeSpan}h | Temps: ${result1.dataRange}°C`;
      } else {
        document.getElementById('test1-info').innerHTML = '<span class="error">✗ FAILED</span>';
      }

      // TEST 2: Real data from CSV
      console.log('\n--- TEST 2: Real CSV Data ---');
      fetch('data/stats.csv')
        .then(r => r.text())
        .then(csv => {
          const lines = csv.trim().split('\n').slice(1); // skip header
          const data = lines
            .map(line => {
              const [timestamp, location, temp, humidity, vpd, dew] = line.split(',');
              return location === 'greenhouse' 
                ? { timestamp: timestamp.trim(), temp: parseFloat(temp), humidity: parseFloat(humidity), vpd: parseFloat(vpd) }
                : null;
            })
            .filter(x => x);

          if (data.length > 0) {
            // Get last 24h
            const lastDate = new Date(data[data.length - 1].timestamp.replace(' ', 'T'));
            const cutoff = new Date(lastDate.getTime() - 24 * 60 * 60 * 1000);
            const last24h = data.filter(d => new Date(d.timestamp.replace(' ', 'T')) >= cutoff);

            const renderer2 = new ChartRenderer('#test2-line', 'temp', 14, 32);
            const result2 = renderer2.render(last24h);

            if (result2) {
              document.getElementById('test2-info').innerHTML = 
                `<span class="success">✓ PASSED</span> | ${result2.pointCount} points | ${result2.timeSpan}h | Temps: ${result2.dataRange}°C`;
            } else {
              document.getElementById('test2-info').innerHTML = '<span class="error">✗ FAILED</span>';
            }
          } else {
            document.getElementById('test2-info').innerHTML = '<span class="error">No greenhouse data in CSV</span>';
          }
        })
        .catch(e => {
          document.getElementById('test2-info').innerHTML = `<span class="error">CSV Load Error: ${e.message}</span>`;
          console.error('CSV load error:', e);
        });
    });
  </script>
</body>
</html>
